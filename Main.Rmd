---
title: "SigMA Simulation"
output: html_notebook
---


```{r}
#Problem: Let coin A have an H probability of 0.2, and let coin B have an H probability of 0.8. This is a simulation for determining the optimal number of flips in order to deliver the highest sensitivity at a particular threshhold for the probability of success.
```



```{r}

library(stats4)
library(mvc)
library(pROC)
source("SimulateCoinFlip.R")
source("PrepareTest.R")
source("TrainModel.R")
```


```{r}
#Declare initial parameters
A_prob <- 0.4
B_prob <- 0.6

N_A <- 50
N_B <- 50
A_Draw_prob <- N_A / (N_A + N_B)
N_Sample <- 100
N_Test <- 20

n_flips_sample <- 10
n_flips_test <- 10
```

```{r}
#Test based on a random coin
SigMA_scores <- TrainModel(A_prob, B_prob, N_A, N_B, N_sample, N_Test, n_flips_sample, A_Draw_prob)
SigMA_scores
set.seed(150)
A_num_test <- rbinom(1, N_Test, A_Draw_prob)
test <- SimulateCoinFlip(A_num_test, n_flips_test, A_prob, B_prob, N_Test)
A_unique_test <- test[1][[1]]
A_counts_test <- test[2][[1]]
B_unique_test <- test[3][[1]]
B_counts_test <- test[4][[1]]

test1 <- PrepareTest(A_unique_test, A_counts_test, B_unique_test, B_counts_test, SigMA_scores)
samples1 <- test1[1][[1]]
prob1 <- test1[2][[1]]


n_flips_sample <- 5
SigMA_scores <- TrainModel(A_prob, B_prob, N_A, N_B, N_sample, N_Test, n_flips_sample)
SigMA_scores
set.seed(150)
A_num_test <- rbinom(1, N_Test, A_Draw_prob)
test <- SimulateCoinFlip(A_num_test, n_flips_test, A_prob, B_prob, N_Test)
A_unique_test <- test[1][[1]]
A_counts_test <- test[2][[1]]
B_unique_test <- test[3][[1]]
B_counts_test <- test[4][[1]]

test1 <- PrepareTest(A_unique_test, A_counts_test, B_unique_test, B_counts_test, SigMA_scores)
samples2 <- test1[1][[1]]
prob12<- test1[2][[1]]


n_flips_sample <- 20
SigMA_scores <- TrainModel(A_prob, B_prob, N_A, N_B, N_sample, N_Test, n_flips_sample)
SigMA_scores
set.seed(150)
A_num_test <- rbinom(1, N_Test, A_Draw_prob)
test <- SimulateCoinFlip(A_num_test, n_flips_test, A_prob, B_prob, N_Test)
A_unique_test <- test[1][[1]]
A_counts_test <- test[2][[1]]
B_unique_test <- test[3][[1]]
B_counts_test <- test[4][[1]]

test1 <- PrepareTest(A_unique_test, A_counts_test, B_unique_test, B_counts_test, SigMA_scores)
samples3 <- test1[1][[1]]
prob3<- test1[2][[1]]


n_flips_sample <- 50
SigMA_scores <- TrainModel(A_prob, B_prob, N_A, N_B, N_sample, N_Test, n_flips_sample)
SigMA_scores
set.seed(150)
A_num_test <- rbinom(1, N_Test, A_Draw_prob)
test <- SimulateCoinFlip(A_num_test, n_flips_test, A_prob, B_prob, N_Test)
A_unique_test <- test[1][[1]]
A_counts_test <- test[2][[1]]
B_unique_test <- test[3][[1]]
B_counts_test <- test[4][[1]]

test1 <- PrepareTest(A_unique_test, A_counts_test, B_unique_test, B_counts_test, SigMA_scores)
samples4 <- test1[1][[1]]
prob4<- test1[2][[1]]

```
```{r}
samples1
samples2
samples3
samples4
```
```{r}
prob1
prob2
prob3
prob4
```


```{r}
#Generate ROC curve based on results
par(pty = "s")
ROC <- plot(roc(samples1, prob1), col = "blue")
ROC <- plot(roc(samples2, prob2), col = "green", add = TRUE)
ROC <- plot(roc(samples3, prob3), col = "red", add = TRUE)
ROC <- plot(roc(samples4, prob4), col = "black", add = TRUE)
```




Add a new chunk by clicking the *Insert Chunk* button on the toolbar or by pressing *Cmd+Option+I*.

When you save the notebook, an HTML file containing the code and output will be saved alongside it (click the *Preview* button or press *Cmd+Shift+K* to preview the HTML file). 

The preview shows you a rendered HTML copy of the contents of the editor. Consequently, unlike *Knit*, *Preview* does not run any R code chunks. Instead, the output of the chunk when it was last run in the editor is displayed.

